rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    function isLoggedIn() {
      return request.auth != null;
    }
    
    function hasClaim(role) {
      return request.auth != null && (
        (
          request.auth.token != null && (
            request.auth.token[role] == true ||
            request.auth.token.role == role
          )
        ) ||
        hasRoleInFirestore(request.auth.uid, role)
      );
    }
    
    function isOwner() {
      return hasClaim('owner');
    }
    
    function getUserData(userId) {
      return exists(/databases/$(database)/documents/users/$(userId)) ?
             get(/databases/$(database)/documents/users/$(userId)).data : null;
    }
    
    function hasRoleInFirestore(userId, role) {
      let userData = getUserData(userId);
      return userData != null && userData.role == role;
    }
    
    function isProfileOwner(profileDocId) {
      return isLoggedIn() &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             getUserData(request.auth.uid).profileId == profileDocId;
    }
    
    // Short-lived scheduling session started by callable function
    function isScheduleSessionActive() {
      return isLoggedIn() &&
             exists(/databases/$(database)/documents/scheduleSessions/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/scheduleSessions/$(request.auth.uid)).data.expiresAt > request.time;
    }

    // --- V2 Helper shims ---
    function isSuperAdmin() { return hasClaim('super_admin'); }
    function isAdmin() { return hasClaim('admin'); }
    function isEmployeeV2() {
      return hasClaim('employee') || (request.auth != null && hasRoleInFirestore(request.auth.uid, 'employee'));
    }
    function isClientV2() {
      return hasClaim('client') || (request.auth != null && hasRoleInFirestore(request.auth.uid, 'client'));
    }
    function isAtLeastAdmin() {
      return isSuperAdmin() || isOwner() || isAdmin();
    }
    // Missing in previous rules: marketing helpers referenced later
    function isMarketing() {
      return hasClaim('marketing') || (request.auth != null && hasRoleInFirestore(request.auth.uid, 'marketing'));
    }

    function currentProfileId() {
      return request.auth != null && getUserData(request.auth.uid) != null ? getUserData(request.auth.uid).profileId : null;
    }

    // --- appSettings Collection Rules ---
    // Stores public-facing company settings used by PDFs and portals
    match /appSettings/{docId} {
      // Anyone can read company settings (non-sensitive info: name/email/phone/logo)
      allow read: if true;
      // Only admins, super_admins, or owner can modify
      allow write: if hasClaim('admin') || hasClaim('super_admin') || isOwner();
    }

    // --- users Collection Rules ---
    match /users/{userId} {
      function userCanUpdatePresence() {
        return request.auth.uid == userId &&
               request.resource.data.diff(resource.data).affectedKeys().hasOnly(['presence']) &&
               request.resource.data.presence is map &&
               (request.resource.data.presence.online == null || request.resource.data.presence.online is bool) &&
               (request.resource.data.presence.lastActive == null || request.resource.data.presence.lastActive is timestamp ||
                // Allow serverTimestamp() sentinel values
                request.resource.data.presence.lastActive == request.time);
      }
      function selfCanUpdateProfile() {
        return request.auth.uid == userId &&
               request.resource.data.diff(resource.data).changedKeys().hasOnly(['fullName','phone','photoUrl','presence']);
      }
      function tryingToChangeRole() {
        return request.resource.data.diff(resource.data).changedKeys().hasAny(['role']);
      }
      
      // Allow users to read their own document without requiring custom claims (for login flow)
      // OR admin/owner to read any document
      allow read: if isLoggedIn() && (request.auth.uid == userId || isAtLeastAdmin());
      // Allow users to create their own document if it doesn't exist (for self-registration)
      allow create: if isLoggedIn() && request.auth.uid == userId && !resource.exists;
      // Updates:
      // - Self: presence OR limited profile fields
      // - Admin/Owner: any non-privileged fields (no direct role changes)
      // - Super Admin: full access (including role changes)
      allow update: if
          // Self updates
          ((request.auth.uid == userId) && (userCanUpdatePresence() || selfCanUpdateProfile() || !resource.exists))
          ||
          // Super admin unrestricted
          isSuperAdmin()
          ||
          // Admin/Owner cannot change role directly (must use callable)
          ((hasClaim('admin') || isOwner()) && !tryingToChangeRole());
      // Only super_admin may delete user docs
      allow delete: if isSuperAdmin();
    }

    // --- clientMasterList Rules ---
    match /clientMasterList/{clientDocId} {
      function clientCanUpdateProfileFields() {
        let allowedKeys = ['contactName', 'phone', 'updatedAt'];
        return request.resource.data.contactName is string && request.resource.data.contactName.size() > 0 &&
               request.resource.data.phone is string &&
               request.resource.data.updatedAt is timestamp &&
               request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedKeys);
      }

      function isClientEmailMatch() {
        return isLoggedIn() && request.auth.token.email == resource.data.email;
      }

      // Allow reading for clients by email match or profile ownership
      // PRIORITY: Check email match first for client portal users, then profile ownership
      allow read: if hasClaim('admin') || isOwner() ||
                     isClientEmailMatch() ||
                     (hasClaim('client') && isProfileOwner(clientDocId)) ||
                     isProfileOwner(clientDocId);
      allow create: if hasClaim('admin') || isOwner();
      allow update: if hasClaim('admin') || isOwner() ||
                       (hasClaim('client') && isProfileOwner(clientDocId) && clientCanUpdateProfileFields()) ||
                       (isClientEmailMatch() && clientCanUpdateProfileFields());
      allow delete: if hasClaim('admin') || isOwner();
    }

    // --- employeeMasterList Rules ---
    match /employeeMasterList/{employeeDocId} {
      function employeeCanUpdateProfileFields() {
        let allowedKeys = ['phone', 'firstName', 'lastName', 'updatedAt'];
        return request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedKeys) &&
               request.resource.data.updatedAt is timestamp;
      }

      function isEmployeeEmailMatch() {
        return isLoggedIn() && request.auth.token.email == resource.data.email;
      }

      // Allow reading for admins, super_admin, owners, or the employee themselves, or clients for staff display
      allow read: if hasClaim('admin') || hasClaim('super_admin') || isOwner() ||
                     (hasClaim('employee') && isProfileOwner(employeeDocId)) ||
                     (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee') && isProfileOwner(employeeDocId)) ||
                     isEmployeeEmailMatch() || isClientV2();
      allow create: if hasClaim('admin') || hasClaim('super_admin') || isOwner();
      allow update: if hasClaim('admin') || hasClaim('super_admin') || isOwner() ||
                       (hasClaim('employee') && isProfileOwner(employeeDocId) && employeeCanUpdateProfileFields()) ||
                       (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee') && isProfileOwner(employeeDocId) && employeeCanUpdateProfileFields());
      allow delete: if hasClaim('admin') || hasClaim('super_admin') || isOwner();
    }

    // --- locations Collection Rules ---
    match /locations/{locationDocId} {
      function isLocationClient() {
        return isLoggedIn() && 
               exists(/databases/$(database)/documents/clientMasterList/$(resource.data.clientProfileId)) &&
               get(/databases/$(database)/documents/clientMasterList/$(resource.data.clientProfileId)).data.email == request.auth.token.email;
      }

      // Allow employees and clients to read location documents
      // Accept either the employee custom claim OR role stored in /users, or client access
      allow read: if hasClaim('admin') || isOwner() || hasClaim('employee') ||
                    (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee')) ||
                    isLocationClient() || isClientV2();
      allow create, update, delete: if hasClaim('admin') || isOwner();
    }

    // --- servicePhotos Collection Rules ---
    match /servicePhotos/{photoId} {
      function isValidPhotoData(photoData) {
        let userDocData = getUserData(request.auth.uid);
        return isLoggedIn() && 
               userDocData != null &&
               (hasClaim('employee') || hasRoleInFirestore(request.auth.uid, 'employee')) &&
               photoData.employeeProfileId == userDocData.profileId &&
               photoData.locationId is string && photoData.locationId != '' &&
               photoData.photoUrl is string && (
               photoData.photoUrl.matches('https://firebasestorage.googleapis.com/.*') ||
               photoData.photoUrl.matches('http://localhost:[0-9]+/v0/b/.*')
               ) &&
               (photoData.uploadedAt is timestamp || photoData.uploadedAt == request.time);
      }

      function employeeCanUpdatePhotoNotes() {
        return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['notes', 'updatedAt']) &&
               request.resource.data.notes is string &&
               request.resource.data.updatedAt is timestamp;
      }

      function isPhotoOwner() {
        let userDocData = getUserData(request.auth.uid);
        return userDocData != null && resource.data.employeeProfileId == userDocData.profileId;
      }

      allow create: if isValidPhotoData(request.resource.data);
      function isPhotoClientByEmail() {
        return isLoggedIn() && 
               exists(/databases/$(database)/documents/locations/$(resource.data.locationId)) &&
               exists(/databases/$(database)/documents/clientMasterList/$(get(/databases/$(database)/documents/locations/$(resource.data.locationId)).data.clientProfileId)) &&
               get(/databases/$(database)/documents/clientMasterList/$(get(/databases/$(database)/documents/locations/$(resource.data.locationId)).data.clientProfileId)).data.email == request.auth.token.email;
      }

      allow read: if hasClaim('admin') || isOwner() || hasClaim('super_admin') ||
                     (resource.data.flagged == true && hasClaim('admin')) ||
                     (hasClaim('employee')) ||
                     (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee')) ||
                     isPhotoClientByEmail() || isClientV2();
      function clientCanFlagPhoto() {
        return isLoggedIn() && 
               request.resource.data.diff(resource.data).affectedKeys().hasOnly(['flagged', 'flaggedAt', 'flaggedByEmail']) &&
               request.resource.data.flagged == true &&
               request.resource.data.flaggedAt is timestamp &&
               request.resource.data.flaggedByEmail is string &&
               isPhotoClientByEmail();
      }

      allow update: if hasClaim('admin') || isOwner() || hasClaim('super_admin') ||
                       (hasClaim('employee') && isPhotoOwner() && employeeCanUpdatePhotoNotes()) ||
                       (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee') && isPhotoOwner() && employeeCanUpdatePhotoNotes()) ||
                       clientCanFlagPhoto();
      allow delete: if hasClaim('admin') || isOwner() ||
                       (hasClaim('employee') && isPhotoOwner()) ||
                       (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee') && isPhotoOwner());
    }

    // --- photoFlags Collection Rules ---
    match /photoFlags/{docId} {
      function isValidFlagData(flagData) {
        return isLoggedIn() && 
               flagData.photoId is string && flagData.photoId != '' &&
               flagData.photoUrl is string && flagData.photoUrl != '' &&
               flagData.flaggedByEmail is string && flagData.flaggedByEmail != '' &&
               flagData.timestamp is timestamp &&
               flagData.clientEmail is string && flagData.clientEmail != '';
      }

      allow read: if hasClaim('admin') || isOwner();
      allow create: if hasClaim('admin') || isOwner() || isValidFlagData(request.resource.data);
      allow update, delete: if hasClaim('admin') || isOwner(); // Only admins/owners can modify/delete
    }

    // --- employeeTimeTracking Rules ---
    match /employeeTimeTracking/{entryDocId} {
      // Helper to check if the logged-in user's profileId from /users collection
      // matches the employeeProfileId stored in the time tracking document.
      function isTimeEntryOwner() {
        let userDocData = getUserData(request.auth.uid); // Use existing helper
        return userDocData != null && resource.data.employeeProfileId == userDocData.profileId;
      }

      // Helper to check if the data being created is valid AND
      // if the employeeProfileId being written matches the creator's own profileId.
      function isValidTimeEntryDataForCreate(entryData) {
        let userDocData = getUserData(request.auth.uid);
        return isLoggedIn() &&
               (hasClaim('employee') || hasRoleInFirestore(request.auth.uid, 'employee')) && // Accept claim or stored role
               userDocData != null &&
               entryData.employeeProfileId == userDocData.profileId && // Creating for themselves
               entryData.locationId is string && entryData.locationId != '' &&
               entryData.status is string && entryData.status == "Clocked In" &&
               entryData.clockInTime is timestamp &&
               entryData.clockOutTime == null &&
               (entryData.clockInCoordinates == null || entryData.clockInCoordinates is latlng) &&
               entryData.createdAt is timestamp &&
               entryData.updatedAt is timestamp;
      }

      // Employees need to update their own entries to clock out
      function employeeCanClockOut(updatedEntryData) {
        let userDocData = getUserData(request.auth.uid);
        // Check that they are only modifying specific fields for clock-out
        let allowedUpdateKeys = ['clockOutTime', 'status', 'clockOutCoordinates', 'updatedAt'];
        return isLoggedIn() &&
               (hasClaim('employee') || hasRoleInFirestore(request.auth.uid, 'employee')) &&
               userDocData != null &&
               resource.data.employeeProfileId == userDocData.profileId && // Must own the record
               updatedEntryData.status == "Clocked Out" &&
               updatedEntryData.clockOutTime is timestamp &&
               (updatedEntryData.clockOutCoordinates == null || updatedEntryData.clockOutCoordinates is latlng) &&
               updatedEntryData.updatedAt is timestamp &&
               request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedUpdateKeys);
      }

      allow read: if hasClaim('admin') || hasClaim('super_admin') || isOwner() ||
                    (isLoggedIn() && (hasClaim('employee') || hasRoleInFirestore(request.auth.uid, 'employee')) && isTimeEntryOwner());

      allow create: if hasClaim('admin') || hasClaim('super_admin') || isOwner() || isValidTimeEntryDataForCreate(request.resource.data);

      // Allow admin to update anything. Allow employee to update ONLY for clocking out.
      allow update: if hasClaim('admin') || hasClaim('super_admin') || isOwner() || employeeCanClockOut(request.resource.data);

      allow delete: if false; // Or if hasClaim('admin') if needed
    }

    // --- serviceHistory Rules (SIMPLIFIED UPDATE RULE v2) ---
    match /serviceHistory/{jobDocId} {
      function isAssignedEmployee() {
         // Check if user is an employee AND assigned to this job
         let userDocData = getUserData(request.auth.uid);
         return isLoggedIn() &&
                userDocData != null &&
                (hasClaim('employee') || hasRoleInFirestore(request.auth.uid, 'employee')) &&
                (
                  // Check new assignedEmployees field (array of UIDs)
                  (resource.data.assignedEmployees is list && 
                   request.auth.uid in resource.data.assignedEmployees) ||
                  // Check legacy employeeAssignments field (array of objects)
                  (resource.data.employeeAssignments is list &&
                   resource.data.employeeAssignments.hasAny([{'employeeId': userDocData.profileId}]))
                );
      }

      function isJobClient() {
        let userDocData = getUserData(request.auth.uid);
        return isLoggedIn() &&
               ((userDocData != null &&
                 userDocData.profileId == resource.data.clientProfileId) ||
                (exists(/databases/$(database)/documents/clientMasterList/$(resource.data.clientProfileId)) &&
                 get(/databases/$(database)/documents/clientMasterList/$(resource.data.clientProfileId)).data.email == request.auth.token.email));
      }

      function isValidServiceHistoryData(jobData) {
        return jobData.clientProfileId is string && jobData.clientProfileId != '' &&
               jobData.locationId is string && jobData.locationId != '' &&
               jobData.serviceDate is timestamp &&
               (jobData.employeeAssignments == null || jobData.employeeAssignments is list) &&
               jobData.status is string && jobData.status != '' &&
               (jobData.createdAt is timestamp || jobData.createdAt == request.time) &&
               (jobData.updatedAt is timestamp || jobData.updatedAt == request.time);
      }

      // Allow employees to read serviceHistory documents (UI filters client-side to their own jobs).
      // Accept either the employee custom claim OR role stored in /users, plus specific allowances.
      allow read: if hasClaim('admin') || isOwner() || hasClaim('employee') ||
                    (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee')) ||
                    isJobClient() || isAssignedEmployee();
      // Creates allowed directly by admin/owner/super_admin (Quick Add)
      allow create: if request.auth != null && (
        hasClaim('admin') || 
        hasClaim('owner') || 
        hasClaim('super_admin') ||
        hasRoleInFirestore(request.auth.uid, 'admin') ||
        hasRoleInFirestore(request.auth.uid, 'owner') ||
        hasRoleInFirestore(request.auth.uid, 'super_admin')
      );

      // Updates:
      // - General admin/owner/super_admin updates are allowed for non-scheduling fields
      // - Scheduling-sensitive fields (assignedEmployees, serviceDate, statusV2)
      //   require an active scheduling session
      // - Archive operations (archived, archivedAt, archivedBy) are allowed for admins/owners
      allow update: if (
        hasClaim('admin') || isOwner() || hasClaim('super_admin')
      ) && (
        // If touching scheduling fields, require active session
        (
          request.resource.data.diff(resource.data).affectedKeys().hasAny(['assignedEmployees','serviceDate','statusV2'])
            ? isScheduleSessionActive()
            : true
        ) &&
        // Archive fields can be updated by admins/owners without session restrictions
        (
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['archived', 'archivedAt', 'archivedBy']) ||
          !request.resource.data.diff(resource.data).affectedKeys().hasAny(['archived', 'archivedAt', 'archivedBy'])
        )
      );
      allow delete: if hasClaim('admin') || isOwner();
    }

    // --- employeeRates Rules ---
    // Read/write allowed for Owner or Super Admin; delete restricted to Super Admin only
    match /employeeRates/{rateId} {
      allow read, write: if isOwner() || hasClaim('super_admin');
      allow delete: if hasClaim('super_admin');
    }

    // --- employeePayroll Rules ---
    match /employeePayroll/{payrollDocId} {
      // Helper to check if the logged-in user's profileId from /users collection
      // matches the employeeProfileId stored in the payroll document.
      function isPayrollOwner() {
        let userDocData = getUserData(request.auth.uid); // Use existing helper
        return userDocData != null && resource.data.employeeProfileId == userDocData.profileId;
      }

      allow read: if hasClaim('admin') || isOwner() ||
                    (isLoggedIn() &&
                     hasRoleInFirestore(request.auth.uid, 'employee') &&
                     isPayrollOwner()); // Employee can read their own payroll doc

      allow update, delete: if hasClaim('admin') || isOwner(); // Only admins/owners can modify/delete
      allow create: if false; // Only Cloud Function creates
    }

    // --- payrollPeriods (closed state banner) ---
    // Cloud Functions write this collection; client needs read-only for admin/owner
    match /payrollPeriods/{payPeriodId} {
      allow read: if hasClaim('admin') || isOwner();
      allow write: if false; // writes are performed via Admin SDK in Cloud Functions
    }

    // --- generalJobNotes Collection Rules ---
    match /generalJobNotes/{noteId} {
      function isValidJobNoteData(noteData) {
        let userDocData = getUserData(request.auth.uid);
        return isLoggedIn() && 
               userDocData != null &&
               (hasClaim('employee') || hasRoleInFirestore(request.auth.uid, 'employee')) &&
               noteData.employeeProfileId == userDocData.profileId &&
               noteData.locationId is string && noteData.locationId != '' &&
               noteData.notes is string && noteData.notes != '' &&
               noteData.createdAt is timestamp;
      }

      function isNoteOwner() {
        let userDocData = getUserData(request.auth.uid);
        return userDocData != null && resource.data.employeeProfileId == userDocData.profileId;
      }

      allow create: if isValidJobNoteData(request.resource.data);
      allow read: if hasClaim('admin') || isOwner() ||
                     (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee')) ||
                     (hasClaim('employee'));
      allow update: if hasClaim('admin') || isOwner() ||
                       (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee') && isNoteOwner()) ||
                       (hasClaim('employee') && isNoteOwner());
      allow delete: if hasClaim('admin') || isOwner() ||
                       (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee') && isNoteOwner()) ||
                       (hasClaim('employee') && isNoteOwner());
    }

    // --- jobNotes Collection Rules (V2-compatible minimal) ---
    match /jobNotes/{noteId} {
      // Read allowed for admins/owner/super_admin/employees. Clients may read their own created notes (email match) when authorRole == 'client'.
      allow read: if hasClaim('admin') || hasClaim('super_admin') || isOwner() || hasClaim('employee') ||
                     (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee')) ||
                     (hasClaim('client') && resource.data.authorRole == 'client' &&
                      resource.data.clientEmail != null && request.auth.token.email == resource.data.clientEmail);
      // Allow create for admins/owner/employees/clients
      allow create: if isLoggedIn() && (hasClaim('admin') || hasClaim('super_admin') || isOwner() || hasClaim('employee') ||
                       hasRoleInFirestore(request.auth.uid, 'employee') || hasClaim('client') || hasRoleInFirestore(request.auth.uid, 'client'));
      // Updates restricted to admin/owner/super_admin
      allow update: if hasClaim('admin') || hasClaim('super_admin') || isOwner();
      // Delete restricted to super_admin
      allow delete: if hasClaim('super_admin');
    }

    // --- serviceAgreements Collection Rules ---
    match /serviceAgreements/{agreementId} {
      function isAgreementClient() {
        let userDocData = getUserData(request.auth.uid);
        return isLoggedIn() &&
               ((userDocData != null &&
                 userDocData.profileId == resource.data.clientId) ||
                (exists(/databases/$(database)/documents/clientMasterList/$(resource.data.clientId)) &&
                 get(/databases/$(database)/documents/clientMasterList/$(resource.data.clientId)).data.email == request.auth.token.email));
      }

      allow read: if hasClaim('admin') || isOwner() || isAgreementClient();
      allow create, update, delete: if hasClaim('admin') || isOwner();
    }

    // --- payrollRecords Collection Rules ---
    match /payrollRecords/{payrollId} {
      function isPayrollRecordOwner() {
        return request.auth != null && resource.data.employeeId == request.auth.uid;
      }
      
      // Allow read: employees can read their own records, admins can read all
      allow read: if hasClaim('admin') || isOwner() || isPayrollRecordOwner();
      allow write, delete: if hasClaim('admin') || isOwner();
    }

    // --- serviceReviews Collection Rules ---
    match /serviceReviews/{reviewId} {
      function isValidReviewData(reviewData) {
        return isLoggedIn() &&
               (reviewData.clientId is string && reviewData.clientId != '' ||
                reviewData.clientProfileId is string && reviewData.clientProfileId != '') &&
               reviewData.jobId is string && reviewData.jobId != '' &&
               reviewData.rating is number && reviewData.rating >= 1 && reviewData.rating <= 5 &&
               reviewData.comment is string &&
               // Accept server timestamps or concrete timestamp values
               (reviewData.timestamp is timestamp || reviewData.timestamp == request.time) &&
               // Optional fields
               (reviewData.locationName == null || reviewData.locationName is string) &&
               (reviewData.serviceDate == null || reviewData.serviceDate is timestamp);
      }

      function isReviewClient() {
        let clientId = resource.data.clientId != null ? resource.data.clientId : resource.data.clientProfileId;
        return isLoggedIn() && 
               exists(/databases/$(database)/documents/clientMasterList/$(clientId)) &&
               get(/databases/$(database)/documents/clientMasterList/$(clientId)).data.email == request.auth.token.email;
      }

      function isReviewClientForCreate(reviewData) {
        // Allow authenticated users to create reviews if they have a valid profileId
        // This is more permissive but secure - relies on application-level authentication
        return isLoggedIn() &&
               request.auth.token.email != null &&
               request.auth.token.email != "" &&
               (reviewData.clientId is string && reviewData.clientId != "" ||
                reviewData.clientProfileId is string && reviewData.clientProfileId != "");
      }

      // Allow admins/owners, the review's client, or any authenticated user with a profileId
      allow read: if hasClaim('admin') || isOwner() || isReviewClient() ||
                     (isLoggedIn() && getUserData(request.auth.uid) != null && getUserData(request.auth.uid).profileId != null);
      // Allow authenticated users to create reviews with proper validation
      allow create: if hasClaim('admin') || isOwner() || isReviewClientForCreate(request.resource.data);
      allow update, delete: if hasClaim('admin') || isOwner();
    }

    // --- invoices Collection Rules ---
    // Admins (incl. owners/super_admins) can fully manage invoices.
    // Clients can read invoices where their auth email matches payeeEmail.
    match /invoices/{invoiceId} {
      // Create/update/delete restricted to admins
      allow create, update, delete: if hasClaim('admin') || isOwner();
      // Read allowed for admins, owners, or the client who owns the invoice (email match)
      allow read: if hasClaim('admin') || isOwner() || 
                     (isLoggedIn() && request.auth.token.email == resource.data.payeeEmail);
    }

    // --- invoices lineItems Subcollection Rules (V2 addition, non-breaking) ---
    // Allow admin/owner/super_admin to manage invoice line items (e.g., supplies added from inventory)
    match /invoices/{invoiceId}/lineItems/{lineItemId} {
      allow read: if hasClaim('admin') || isOwner() || hasClaim('super_admin');
      allow create, update: if hasClaim('admin') || isOwner() || hasClaim('super_admin');
      allow delete: if hasClaim('super_admin');
    }

    // --- Stripe Extension Collections (firestore-stripe-payments) ---
    // Allow authenticated users to create their own checkout sessions
    // The extension backend will populate url or error back on the same doc
    match /customers/{uid} {
      allow read: if isLoggedIn() && request.auth.uid == uid; // read own customer doc if needed
      allow write: if false; // base doc is managed by the extension

      match /checkout_sessions/{sessionId} {
        allow create: if isLoggedIn() && request.auth.uid == uid
                       && request.resource.data.keys().hasOnly(['price','quantity','success_url','cancel_url','allow_promotion_codes','metadata']); // user starts checkout with restricted fields
        allow read: if isLoggedIn() && request.auth.uid == uid; // read back url / error
        allow update, delete: if false; // extension updates these documents
      }

      match /payments/{paymentId} {
        allow read: if isLoggedIn() && request.auth.uid == uid; // user can read their payments
        allow write: if false; // extension writes payments
      }
    }

    // --- presence Collection Rules (V2 - FIXED) ---
    // Allow any authenticated user to write their own presence document; everyone authenticated may read
    match /presence/{uid} {
      function isValidPresenceData(data) {
        return data.uid is string && data.uid == uid &&
               (data.displayName == null || data.displayName is string) &&
               (data.online == null || data.online is bool) &&
               (data.lastActive == null || data.lastActive is timestamp ||
                // Allow serverTimestamp() sentinel values
                data.lastActive == request.time);
      }
      
      // Allow any authenticated user to read presence documents
      allow read: if request.auth != null;
      
      // Allow users to create/update their own presence document with valid schema
      allow create, update: if request.auth != null && 
                              request.auth.uid == uid && 
                              isValidPresenceData(request.resource.data);
      
      // Only super admin can delete presence documents
      allow delete: if isSuperAdmin();
    }

    // --- auditLogs Collection Rules ---
    // Functions-only writes; read allowed for Admin/Owner/Super Admin
    match /auditLogs/{logId} {
      allow read: if hasClaim('admin') || hasClaim('super_admin') || isOwner();
      allow create, update, delete: if false;
    }

    // --- supportTickets Collection Rules ---
    match /supportTickets/{ticketId} {
      function isValidTicketData(ticketData) {
        return ticketData.clientId is string && ticketData.clientId != '' &&
               ticketData.clientName is string && ticketData.clientName != '' &&
               ticketData.email is string && ticketData.email != '' &&
               ticketData.subject is string && ticketData.subject != '' &&
               ticketData.message is string && ticketData.message != '' &&
               ticketData.status is string && ticketData.status == "open" &&
               ticketData.createdAt is timestamp &&
               ticketData.lastUpdated is timestamp;
      }

      function isTicketOwner() {
        return request.auth != null &&
               resource.data.email == request.auth.token.email;
      }

      function isTicketOwnerForCreate(ticketData) {
        return request.auth != null &&
               ticketData.email == request.auth.token.email;
      }

      // Allow reading for authenticated users who own the ticket OR admins/owners
      allow read: if hasClaim('admin') || isOwner() || isTicketOwner();

      // Allow creating tickets for authenticated users with valid data and matching email
      allow create: if request.auth != null &&
                       isValidTicketData(request.resource.data) &&
                       isTicketOwnerForCreate(request.resource.data);

      // Allow updating for admins/owners OR ticket owners (for status updates)
      allow update: if hasClaim('admin') || isOwner() || isTicketOwner();

      // Allow deleting for admins/owners only
      allow delete: if hasClaim('admin') || isOwner();
    }

    // --- supportComments Collection Rules ---
    match /supportComments/{commentId} {
      function isValidCommentData(commentData) {
        return commentData.ticketId is string && commentData.ticketId != '' &&
               commentData.authorRole in ['admin', 'employee', 'client'] &&
               (commentData.text == null || commentData.text is string) &&
               (commentData.attachments == null || commentData.attachments is list) &&
               commentData.createdAt is timestamp;
      }

      // Check if the authenticated user owns the ticket (for clients)
      function isTicketOwner() {
        return request.auth != null &&
               exists(/databases/$(database)/documents/supportTickets/$(resource.data.ticketId)) &&
               get(/databases/$(database)/documents/supportTickets/$(resource.data.ticketId)).data.email == request.auth.token.email;
      }

      // Check if the authenticated user can comment on the ticket
      function canCommentOnTicket() {
        return request.auth != null &&
               (hasClaim('admin') || isOwner() || hasClaim('employee') ||
                (hasClaim('client') && isTicketOwner()));
      }

      // Check if the authenticated user can read comments on the ticket
      function canReadComments() {
        return request.auth != null &&
               (hasClaim('admin') || isOwner() || hasClaim('employee') ||
                (hasClaim('client') && isTicketOwner()));
      }

      // Allow reading comments for ticket owners or admins/employees
      allow read: if canReadComments();

      // Allow creating comments for authenticated users who can comment on the ticket
      allow create: if request.auth != null &&
                       isValidCommentData(request.resource.data) &&
                       canCommentOnTicket();

      // Allow updating/deleting comments for admins/owners only (for moderation)
      allow update, delete: if hasClaim('admin') || isOwner();
    }

    // --- counters Collection Rules ---
    match /counters/ids {
      allow read: if hasClaim('admin') || isOwner();
      allow write: if false; // Only Cloud Function modifies
    }

    // --- V2: leads (CRM) ---
    // Admin/Owner/Marketing can read and write; delete restricted to super_admin
    match /leads/{leadId} {
      allow read: if hasClaim('admin') || isOwner() || hasClaim('super_admin');
      allow create, update: if hasClaim('admin') || isOwner();
      allow delete: if hasClaim('super_admin');
    }

    // --- V2: timesheets ---
    // Employees can read/write their own timesheets; admins can manage everything
    match /timesheets/{tsId} {
      function isTimesheetOwner() {
        // employeeId stores the employee profileId; compare against currentProfileId()
        return request.auth != null && currentProfileId() != null && resource.data.employeeId == currentProfileId();
      }
      
      function isTimesheetOwnerForCreate(data) {
        // employeeId stores the employee profileId; compare against currentProfileId()
        return request.auth != null && currentProfileId() != null && data.employeeId == currentProfileId();
      }
      
      function employeeCanUpdateFields(data) {
        // Employees can only update specific fields
        let allowedFields = ['start', 'end', 'hours', 'jobId', 'employeeApproved', 'employeeComment'];
        return request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedFields);
      }
      
      function isValidTimesheetData(data) {
        return data.employeeId is string && data.employeeId != '' &&
               data.start is timestamp &&
               (data.end == null || data.end is timestamp) &&
               data.hours is number && data.hours >= 0 &&
               // units is required for per-visit calculations; allow 0 or positive numbers
               (data.units == null || (data.units is number && data.units >= 0));
      }
      
      // Allow read: employees can read their own timesheets, admins can read all
      allow read: if hasClaim('admin') || isOwner() || hasClaim('super_admin') || isTimesheetOwner();
      
      // Allow create: employees can create their own timesheets, admins can create any
      allow create: if (request.auth != null && isTimesheetOwnerForCreate(request.resource.data) && isValidTimesheetData(request.resource.data)) ||
                       hasClaim('admin') || isOwner() || hasClaim('super_admin');
      
      // Allow update: employees can update their own timesheets with restrictions, admins can update any
      allow update: if (isTimesheetOwner() && employeeCanUpdateFields(request.resource.data)) ||
                       hasClaim('admin') || isOwner() || hasClaim('super_admin');
      
      allow delete: if hasClaim('admin') || isOwner() || hasClaim('super_admin');
    }

    // --- V2: payrollRuns ---
    // Parent documents are restricted to finance roles. Summaries expose paystubs per employeeProfileId.
    match /payrollRuns/{runId} {
      function isLockedRun() {
        return resource != null &&
               resource.data != null &&
               resource.data.status is string &&
               resource.data.status == "locked";
      }

      function employeeCanReadRun() {
        return (request.auth != null && isEmployeeV2()) &&
               (
                 isLockedRun() ||
                 (currentProfileId() != null &&
                  exists(/databases/$(database)/documents/payrollRuns/$(runId)/summaries/$(currentProfileId())))
               );
      }

      allow read: if hasClaim('admin') || isOwner() || hasClaim('super_admin') || employeeCanReadRun();
      allow create, update: if hasClaim('admin') || isOwner() || hasClaim('super_admin');
      allow delete: if hasClaim('super_admin');

      match /summaries/{employeeProfileId} {
        function isSummaryOwner() {
          return currentProfileId() != null && currentProfileId() == employeeProfileId;
        }

        // Admins may read any summary; employees only their own. Writes are Cloud Function only.
        allow read: if hasClaim('admin') || isOwner() || hasClaim('super_admin') || isSummaryOwner();
        allow write: if false;
      }
    }

    // --- V2: payments (Finance hub summary) ---
    match /payments/{paymentId} {
      allow read: if hasClaim('admin') || isOwner() || hasClaim('super_admin');
      allow create, update: if hasClaim('admin') || isOwner();
      allow delete: if hasClaim('super_admin');
    }

    // --- expenses (V2 Finance hub - non-payroll outflows; mirror of inventory purchases) ---
    // Owner and Super Admin may read/write; delete restricted to Super Admin only.
    match /expenses/{expenseId} {
      allow read: if isOwner() || hasClaim('super_admin');
      allow create: if isOwner() || hasClaim('super_admin');
      allow update: if isOwner() || hasClaim('super_admin');
      allow delete: if hasClaim('super_admin');
    }

    // --- inventoryItems (V2) ---
    // Owner/Super Admin: read/write; Employees: read-only; Delete: Super Admin only
    match /inventoryItems/{itemId} {
      allow read: if hasClaim('admin') || isOwner() || hasClaim('super_admin') ||
                     hasClaim('employee') || (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee'));
      allow create, update: if isOwner() || hasClaim('super_admin');
      allow delete: if hasClaim('super_admin');
    }

    // --- inventoryTransactions (V2) ---
    // Immutable ledger: create by Owner/Super Admin; Employees read-only; Delete: Super Admin only
    match /inventoryTransactions/{txId} {
      allow read: if hasClaim('admin') || isOwner() || hasClaim('super_admin') ||
                     hasClaim('employee') || (isLoggedIn() && hasRoleInFirestore(request.auth.uid, 'employee'));
      allow create: if isOwner() || hasClaim('super_admin');
      allow update: if false; // immutable entries
      allow delete: if hasClaim('super_admin');
    }

    // --- analyticsDaily & analyticsMonthly (read-only to admin/owner) ---
    match /analyticsDaily/{dateId} {
      allow read: if hasClaim('admin') || isOwner();
      allow write: if false; // writes via Cloud Functions only
    }

    match /analyticsMonthly/{monthId} {
      allow read: if hasClaim('admin') || isOwner();
      allow write: if false; // writes via Cloud Functions only
    }

    // --- mediaAssets Collection Rules ---
    match /mediaAssets/{assetId} {
      // Allow reading for admins/owners OR if the asset is public OR if user is a client and asset is for clients
      allow read: if hasClaim('admin') || isOwner() || hasClaim('super_admin') ||
                     (isLoggedIn() && (
                       resource.data.audience == 'public' ||
                       (hasClaim('client') || hasRoleInFirestore(request.auth.uid, 'client')) ||
                       (hasClaim('employee') || hasRoleInFirestore(request.auth.uid, 'employee'))
                     ));
      
      // Allow creating for admins/owners only
      allow create: if hasClaim('admin') || isOwner() || hasClaim('super_admin');
      
      // Allow updating for admins/owners only
      allow update: if hasClaim('admin') || isOwner() || hasClaim('super_admin');
      
      // Allow deleting for admins/owners only
      allow delete: if hasClaim('admin') || isOwner() || hasClaim('super_admin');
    }

    // --- trainingCompletions Collection Rules ---
    match /trainingCompletions/{completionId} {
      function isValidCompletionData(completionData) {
        return isLoggedIn() && 
               completionData.acknowledged == true &&
               completionData.assetId is string && completionData.assetId != '' &&
               completionData.completedAt is timestamp;
      }

      function isCompletionOwner() {
        return isLoggedIn() && 
               (resource.data.clientUserId == request.auth.uid ||
                resource.data.userId == request.auth.uid);
      }

      // Allow reading for admins/owners OR if the completion belongs to the current user
      allow read: if hasClaim('admin') || isOwner() || hasClaim('super_admin') ||
                     (isLoggedIn() && isCompletionOwner());
      
      // Allow creating for authenticated users (for acknowledging assets)
      allow create: if isLoggedIn() && isValidCompletionData(request.resource.data) &&
                       (request.resource.data.clientUserId == request.auth.uid ||
                        request.resource.data.userId == request.auth.uid);
      
      // Allow updating for admins/owners only
      allow update: if hasClaim('admin') || isOwner() || hasClaim('super_admin');
      
      // Allow deleting for admins/owners only
      allow delete: if hasClaim('admin') || isOwner() || hasClaim('super_admin');
    }

    // --- V2: activities (CRM + Training tasks) ---
    // UI: Admin/Owner/Marketing manage activities; employees can READ activities where entityId == their profileId (e.g., training tasks/type='task').
    match /activities/{activityId} {
      allow read: if isAdmin() || isOwner() || isMarketing() ||
                    (isEmployeeV2() && resource.data.entityId != null && resource.data.entityId == currentProfileId());
      allow create: if isAdmin() || isOwner() || isMarketing();
      allow update: if isAdmin() || isOwner() || isMarketing();
      allow delete: if isSuperAdmin();
    }

    // --- V2: campaigns (Marketing) ---
    match /campaigns/{campaignId} {
      allow read: if isAdmin() || isOwner() || isMarketing();
      allow create: if isAdmin() || isOwner() || isMarketing();
      allow update: if isAdmin() || isOwner() || isMarketing();
      allow delete: if isSuperAdmin();
    }

    // --- V2: campaignActivities (log of sends/opens/clicks) ---
    match /campaignActivities/{id} {
      allow read: if isAdmin() || isOwner() || isMarketing();
      allow create: if isAdmin() || isOwner() || isMarketing();
      allow update: if isAdmin() || isOwner() || isMarketing();
      allow delete: if isSuperAdmin();
    }

    // --- V2: notifications (in-app user inbox; multi-channel queue) ---
    // UI: Users can read their own docs and mark as read; Admin/Owner can read all and manage queue.
    match /notifications/{nid} {
      function isRecipient() { return request.auth != null && resource.data.userId == request.auth.uid; }
      function allowedUserUpdate() {
        // Users may only set status='read' and readAt timestamp on their own docs
        return isRecipient() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status','readAt']) &&
               request.resource.data.status in ['read','sent','queued'] &&
               (request.resource.data.readAt == null || request.resource.data.readAt is timestamp);
      }
      allow read: if isAdmin() || isOwner() || isSuperAdmin() || isRecipient();
      allow create: if isAdmin() || isOwner() || isSuperAdmin();
      allow update: if isAdmin() || isOwner() || isSuperAdmin() || allowedUserUpdate();
      allow delete: if isSuperAdmin();
    }

    // --- V2: settings (singleton: settings/org) ---
    // UI: Owner and super_admin can modify settings; others read-only as needed by apps.
    match /settings/{docId} {
      allow read: if request.auth != null; // any authenticated user may read
      // Hardened: writes restricted to owner or super_admin
      allow create, update: if isOwner() || isSuperAdmin();
      allow delete: if isSuperAdmin();
    }

    // --- V2: trainingAssignments ---
    // Employees can read their own assignments; admins can manage all
    match /trainingAssignments/{assignmentId} {
      function isAssignmentOwner() {
        return request.auth != null && resource.data.userId == request.auth.uid;
      }
      
      function isAssignmentOwnerForCreate(data) {
        return request.auth != null && data.userId == request.auth.uid;
      }
      
      function isValidAssignmentData(data) {
        return data.userId is string && data.userId != '' &&
               data.moduleId is string && data.moduleId != '' &&
               (data.assignedAt == null || data.assignedAt is timestamp) &&
               (data.dueAt == null || data.dueAt is timestamp);
      }
      
      // Allow read: employees can read their own assignments, admins can read all
      allow read: if hasClaim('admin') || isOwner() || hasClaim('super_admin') || isAssignmentOwner();
      
      // Allow create: admins can create any assignment, employees can create their own
      allow create: if (request.auth != null && isAssignmentOwnerForCreate(request.resource.data) && isValidAssignmentData(request.resource.data)) ||
                       hasClaim('admin') || isOwner() || hasClaim('super_admin');
      
      // Allow update: admins can update any assignment
      allow update: if hasClaim('admin') || isOwner() || hasClaim('super_admin');
      
      allow delete: if hasClaim('admin') || isOwner() || hasClaim('super_admin');
    }

    // --- V2: trainingModules ---
    // Employees can read modules; admins can manage all
    match /trainingModules/{moduleId} {
      function isValidModuleData(data) {
        return data.title is string && data.title != '' &&
               (data.description == null || data.description is string) &&
               data.audience in ['employees', 'clients'] &&
               (data.assetIds == null || data.assetIds is list) &&
               (data.passScore == null || data.passScore is number);
      }
      
      // Allow read: employees can read modules, admins can read all
      allow read: if hasClaim('admin') || isOwner() || hasClaim('super_admin') || isEmployeeV2();
      
      // Allow create/update: admins only
      allow create, update: if (hasClaim('admin') || isOwner() || hasClaim('super_admin')) && isValidModuleData(request.resource.data);
      
      allow delete: if hasClaim('admin') || isOwner() || hasClaim('super_admin');
    }

    // --- V2: templates (Marketing) ---
    // Templates for email campaigns and other marketing materials
    match /templates/{templateId} {
      allow read: if isAdmin() || isOwner() || isMarketing();
      allow create: if isAdmin() || isOwner() || isMarketing();
      allow update: if isAdmin() || isOwner() || isMarketing();
      allow delete: if isSuperAdmin();
    }

  } // End match /databases/{database}/documents
} // End service cloud.firestore
